/**
 * An object capable of reflect light
 *
 * @class Mirror
 * @param p1 {Object} An edge of the object
 * @param p2 {Object} Another edge of the object
 */
var Mirror = function (p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
};

inherits(Mirror, Opaque);

Mirror.prototype.generateRays = function (rays) {
    // Skip if the given ray has been generated by the current body
    if (rays && rays.parentBody === this)
        return;

    Opaque.prototype.generateRays.call(this, rays);
};

Mirror.prototype.computeRays = function (rays) {
    // Skip if the given ray has been generated by the current body
    if (rays && rays.parentBody === this)
        return;

    Opaque.prototype.computeRays.call(this, rays);
};

/**
 * Generate new RayCollection based on the incident rays
 *
 * @method computeReflection
 * @param rays {RayCollection}
 * @return {RayCollection} A new RayCollection
 */
Mirror.prototype.computeReflection = function (rays) {
    // Skip if the given ray has been generated by the current body
    if (rays && rays.parentBody === this)
        return null;

    var p;
    var reflectedRays = [];

    var mirrorSegment = new LineSegment(this.p1, this.p2);
    for (var i = 0; i < rays.data.length; i++) {
        if (this._ownsRay(rays.data[i]))
            continue;
        // Check whether this new object intersects existing Rays
        p = rays.data[i].intersectionPoint(mirrorSegment);
        if (p !== null) {
            var reflectedVector = Vector2D.reflect(rays.data[i].toVector(), mirrorSegment.toVector());
            var newRay = new Ray(p, reflectedVector);
            newRay.orientation = rays.data[i].orientation*-1; // XXX
            reflectedRays.push(newRay);
        }
    }

    // Create a vector that goes from the source of light to the edges of the object
    var vp1 = (new LineSegment(rays.lightPos, this.p1)).toVector();
    var vp2 = (new LineSegment(rays.lightPos, this.p2)).toVector();

    var order = vp1.crossProduct(vp2);

    if (!rays.contains(this.p1))
        vp1 = null;

    if (!rays.contains(this.p2))
        vp2 = null;

    if (vp1) {
        var vp1r = Vector2D.reflect(vp1, mirrorSegment.toVector());
        var rp1r = new Ray(this.p1, vp1r);
        if (order > 0)
            rp1r.orientation = -1;
        reflectedRays.push(rp1r);
    }

    if (vp2) {
        var vp2r = Vector2D.reflect(vp2, mirrorSegment.toVector());
        var rp2r = new Ray(this.p2, vp2r);
        if (order < 0)
            rp2r.orientation = -1;
        reflectedRays.push(rp2r);
    }

    var rayCollection = RayCollection.fromArray(reflectedRays);
    if (!rayCollection)
        return null;

    rayCollection.parentBody = this;
    return rayCollection;
};

/**
 * Paint the object to a context
 *
 * @method paint
 * @param context {CanvasRenderingContext2D} A canvas 2D context
 */
Mirror.prototype.paint = function (context) {
    context.save();
    context.setLineDash([3]);
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(this.p1.x, this.p1.y);
    context.lineTo(this.p2.x, this.p2.y);
    context.stroke();
    context.restore();
};
